3.- ¿Cómo modelaron el resultado de haber desarrollado un combate? ¿qué opciones consideraron y por qué se quedaron con la que entregaron y por qué descartaron a las otras?

Para el resultado de un combate, lo importante a modelar eran 2 datos: el bando ganador (o la falta de uno) y la cantidad de rondas que duró el combate. Entre las opciones posibles para modelar esto, las dos principales que se consideraron fueron un objeto y un diccionario.

El objeto es una de las primeras ideas que podrían surgir, ya que creamos objetos para los combatientes, el orquestador, e incluso los tests. El objeto Respuesta no es muy complejo, como ya se mencionó, sólo necesita almacenar y devolver 2 valores, por lo que su implementación es trivial: un mensaje #declararGanador y otro #obtenerGanador, y sus análogos para las rondas.
Sin embargo, esta simplicidad plantea ciertas dudas: ¿Por qué habría de crearse un objeto sólo para esta tarea? Añade complejidad y el único propósito que cumple es almacenar y devolver dos valores. Sirve nada más como intermediario entre #desarrollarCombateDuranteRondas: y los métodos que necesiten del resultado (los assert). Entonces, uno podría plantearse eliminar el intermediario y que el método devuelva directamente el resultado.

Ese es el problema que resuelve un diccionario. Los diccionarios son objetos que ya vienen en el sistema cuyo propósito es específicamente almacenar varios valores con una "clave", que podemos interpretar como si fuera un "nombre" para el valor. Esto los hace más claros que otras colecciones ya que en vez de almacenar arbitrariamente el ganador en la posición 0 y la cantidad de rondas en la posición 1, estamos almacenando el ganador en la clave '#ganador', y la cant. de rondas en la clave '#rondas'. Esto nos evita crear más objetos de los necesarios.
La desventaja de esta solución es que la sintaxis es menos clara (p. ej.: Resultado obtenerBandoGanador para el objeto vs. resultado valueAt: #ganador para el dict) y es un poco menos flexible si en el futuro se llegara a dar el caso de que el resultado deba hacer algo que no sea almacenar y devlver un valor/objeto.

Al final se decidió implementarlo como un objeto, en vista de que es una solución un poco más consistente con el resto del ejercicio (y del resto de las cosas desarrolladas en la materia), que la sintaxis es un poco más clara, y que es más flexible. De todos modos en este caso en específico la implementación con el diccionario hubiera sido funcionalmente idéntica, con la misma dificultad de implementación, y con muy pocas diferencias en el resto de aspectos.